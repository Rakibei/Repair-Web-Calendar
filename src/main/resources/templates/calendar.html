<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kalender</title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png" />
    <link rel="shortcut icon" href="/images/favicon.png" />

    <!-- Performance: preconnect to CDNs used below -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <link rel="preconnect" href="https://kit.fontawesome.com" crossorigin />

    <!-- Preload hero/logo image to improve LCP -->
    <link
      rel="preload"
      href="/images/Perform_logo_white.avif"
      as="image"
      imagesrcset="/images/Perform_logo_white.avif"
      imagesizes="180px"
    />

    <!-- Bootstrap CSS (preloaded, non‑blocking) -->
    <link href="/css/bootstrap.css" rel="stylesheet" />

    <!-- Calendar CSS (preloaded, non‑blocking) -->
    <link href="/css/calendar.css" rel="stylesheet" />

    <!-- Navbar CSS (preloaded, non‑blocking) -->
    <link href="/css/navbar.css" rel="stylesheet" />
  </head>
  <body class="d-flex justify-content-center p-4" id="calendar-container">
    <div class="container h-100">
      <div class="d-flex justify-content-end align-items-center mb-3 h-100">
        <div class="h-100" id="calendar"></div>
      </div>

      <!-- Right-click context menu -->
      <div id="eventContextMenu" class="event-contextmenu">
        <a class="dropdown-item" data-action="open">Åbn</a>
        <a class="dropdown-item" data-action="openNewTab">Åbn i ny fane</a>
        <a class="dropdown-item" data-action="edit">Rediger</a>
        <div class="dropdown-item position-relative" id="statusSubmenuRoot">
          <span>Set Status</span>
          <span class="fa-solid fa-angle-right"></span>
          <div
            id="statusSubmenu"
            class="event-submenu"
            style="display: none; position: absolute; top: 0; left: 100%; min-width: 180px"
          >
            <a class="dropdown-item" data-action="setStatus" data-status="notDelivered">Ikke Indleveret</a>
            <a class="dropdown-item" data-action="setStatus" data-status="delivered">Indleveret</a>
            <a class="dropdown-item" data-action="setStatus" data-status="inProgress">Igangværende</a>
            <a class="dropdown-item" data-action="setStatus" data-status="missingPart">Mangler del</a>
            <a class="dropdown-item" data-action="setStatus" data-status="finished">Færdig</a>
            <a class="dropdown-item" data-action="setStatus" data-status="pickedUp">Afhentet</a>
          </div>
        </div>
        <div class="dropdown-divider"></div>
        <a class="dropdown-item text-danger" data-action="delete">Slet</a>
      </div>

      <!-- Create Job Modal -->
      <div th:replace="~{modals :: create-job-modal}"></div>
      <div th:replace="~{modals :: full-edit-job-modal}"></div>
    </div>

    <!-- Navigation Bar -->
    <nav>
      <script src="/js/navbar.js"></script>
    </nav>

    <!-- Bootstrap JS (bundle includes Popper) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <!-- FullCalendar JS -->
    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.19/index.global.min.js"></script>

    <!-- Custom JavaScript Modules -->
    <script src="/js/html.js"></script>
    <script src="/js/modals/create-job-modal.js"></script>
    <script src="/js/modals/full-edit-job-modal.js"></script>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        /**
         * Converts a Job object from the API into a FullCalendar event object.
         *
         * @param {Object} job - Job data from the API
         * @returns {Object} FullCalendar event object with title, dates, colors, and extended properties
         */
        function mapJobToEvent(job) {
          const statusName = job.status?.name || statusIdToName[job.status?.id] || 'notDelivered';
          const statusId = job.status?.id || statusNameToId[statusName] || 1;
          const colors = statusToColors(statusName);

          // Build the displayed title to include customer name
          const jobTitle = job.title || '';
          const customer = job.customer_name || '';
          // If both present: "Job Title — Customer Name"
          // If only customer present: "Customer Name"
          // If only title present: "Job Title"
          let displayTitle;
          if (jobTitle) {
            displayTitle = jobTitle;
          } else if (customer) {
            displayTitle = customer;
          } else {
            displayTitle = 'Job';
          }

          return {
            id: job.id,
            title: displayTitle,
            start: job.date,
            end: job.date ? new Date(job.date).getTime() + (job.work_time_minutes || 0) * 60000 : null,
            backgroundColor: colors.backgroundColor,
            borderColor: colors.borderColor,
            textColor: colors.textColor,
            classNames: [`status-${statusName}`],
            extendedProps: {
              // Store original fields for popover display and editing
              original_title: job.title || '',
              customer_name: job.customer_name,
              customer_phone: job.customer_phone,
              job_description: job.job_description,
              work_time_minutes: job.work_time_minutes,
              price_per_minute: job.price_per_minute,
              status: statusName,
              status_id: statusId,
            },
          };
        }

        /**
         * Fetches all jobs from the API and initializes the calendar with them.
         *
         * @param {Object} calendar - FullCalendar instance
         * @returns {Promise} Promise that resolves when jobs are loaded
         */
        function fetchJobsAndInit(calendar) {
          return fetch('/api/jobs')
            .then((r) => r.json())
            .then((jobs) => {
              const events = jobs.map(mapJobToEvent);
              calendar.removeAllEvents();
              calendar.addEventSource(events);
            });
        }

        /**
         * Formats a Date object to local ISO format without timezone.
         * Format: "YYYY-MM-DDTHH:mm:ss"
         *
         * @param {Date} date - Date object to format
         * @returns {string|null} Formatted date string or null if no date provided
         */
        function formatLocalDateTime(date) {
          if (!date) return null;
          const pad = (n) => String(n).padStart(2, '0');
          const Y = date.getFullYear();
          const M = pad(date.getMonth() + 1);
          const D = pad(date.getDate());
          const hh = pad(date.getHours());
          const mm = pad(date.getMinutes());
          const ss = pad(date.getSeconds());
          return `${Y}-${M}-${D}T${hh}:${mm}:${ss}`;
        }

        /**
         * Builds a complete API payload from a FullCalendar event object.
         * Used for PUT requests to update job data.
         *
         * @param {Object} event - FullCalendar EventApi object
         * @returns {Object} Job payload ready for API submission
         */
        function buildPayloadFromEvent(event) {
          const ep = event.extendedProps || {};
          const statusId = ep.status_id || 1;

          // Prefer the original raw title (stored separately from display title)
          const rawTitle =
            ep.original_title !== undefined && ep.original_title !== null && ep.original_title !== ''
              ? ep.original_title
              : event.title || '';

          return {
            title: rawTitle,
            customer_name: ep.customer_name || '',
            customer_phone: ep.customer_phone || '',
            job_description: ep.job_description || '',
            work_time_minutes: ep.work_time_minutes || 0,
            price_per_minute: ep.price_per_minute || 0,
            date: event.start ? formatLocalDateTime(event.start) : null,
            status: { id: parseInt(statusId, 10) },
          };
        }

        // Context Menu State
        let contextTargetEvent = null;
        const contextMenuEl = document.getElementById('eventContextMenu');

        /**
         * Hides the context menu and clears the target event reference.
         */
        function hideContextMenu() {
          contextMenuEl.style.display = 'none';
          contextTargetEvent = null;
        }

        /**
         * Displays the context menu at the specified coordinates for the given event.
         * Dynamically updates menu items based on event properties and hides current status option.
         *
         * @param {number} x - X coordinate (clientX)
         * @param {number} y - Y coordinate (clientY)
         * @param {Object} eventApi - FullCalendar EventApi object
         */
        function showContextMenu(x, y, eventApi) {
          contextTargetEvent = eventApi;

          const ep = eventApi.extendedProps || {};
          const title = (ep.original_title || eventApi.title || 'Job').toString();

          // Update menu items with event-specific text
          contextMenuEl.querySelector('[data-action="open"]').textContent = `Åbn "${title}"`;
          contextMenuEl.querySelector('[data-action="openNewTab"]').textContent = `Åbn "${title}" i ny fane`;
          contextMenuEl.querySelector('[data-action="edit"]').textContent = `Rediger "${title}"`;

          // Hide the current status from the submenu to avoid confusion
          const currentStatusName = (ep.status || '').toString();
          const submenuItems = contextMenuEl.querySelectorAll(
            '#statusSubmenu a.dropdown-item[data-action="setStatus"]',
          );
          submenuItems.forEach((a) => {
            const name = a.getAttribute('data-status');
            a.style.display = name === currentStatusName ? 'none' : '';
          });

          // Setup cascading submenu behavior (only once)
          const root = contextMenuEl.querySelector('#statusSubmenuRoot');
          const submenu = contextMenuEl.querySelector('#statusSubmenu');
          if (root && submenu && !root.dataset.bound) {
            root.dataset.bound = '1';
            let submenuHideTimer = null;

            const openSubmenu = () => {
              submenu.style.display = 'block';
              const rootRect = root.getBoundingClientRect();
              const submenuRect = submenu.getBoundingClientRect();
              const vw = window.innerWidth;
              const vh = window.innerHeight;
              let top = 0;
              let left = rootRect.width;

              // Position submenu to the left if it would overflow right edge
              if (rootRect.right + submenuRect.width > vw) {
                left = -submenuRect.width;
              }
              // Adjust vertical position if it would overflow bottom
              if (rootRect.top + submenuRect.height > vh) {
                top = Math.max(0, vh - (rootRect.top + submenuRect.height) - 4);
              }
              submenu.style.top = `${top}px`;
              submenu.style.left = `${left}px`;
            };

            const scheduleHide = () => {
              clearTimeout(submenuHideTimer);
              submenuHideTimer = setTimeout(() => {
                submenu.style.display = 'none';
              }, 200);
            };

            const cancelHide = () => clearTimeout(submenuHideTimer);

            // Hover events for cascading behavior
            root.addEventListener('mouseenter', () => {
              cancelHide();
              openSubmenu();
            });
            root.addEventListener('mouseleave', scheduleHide);
            submenu.addEventListener('mouseenter', cancelHide);
            submenu.addEventListener('mouseleave', scheduleHide);
          }

          // Position main menu within viewport bounds
          const menuRect = { width: 240, height: 260 };
          const vw = window.innerWidth,
            vh = window.innerHeight;
          let left = x,
            top = y;
          if (left + menuRect.width > vw) left = vw - menuRect.width - 10;
          if (top + menuRect.height > vh) top = vh - menuRect.height - 10;

          contextMenuEl.style.left = left + 'px';
          contextMenuEl.style.top = top + 'px';
          contextMenuEl.style.display = 'block';
        }

        // FullCalendar Configuration and Initialization
        const calendarEl = document.getElementById('calendar');
        const calendar = new FullCalendar.Calendar(calendarEl, {
          customButtons: {
            // Custom btn in the full calendar tool line, to open the create job modal
            createJob: {
              text: 'Tilføj reparation',
              click: function () {
                if (window.openCreateJobModal) window.openCreateJobModal();
              },
            },
          },
          initialView: 'timeGridWeek',
          headerToolbar: {
            left: 'prev,title,next,today',
            center: 'dayGridMonth,timeGridWeek,timeGridDay',
            right: 'createJob',
          },
          navLinks: true,
          displayEventTime: false,
          slotMinTime: '09:00:00',
          slotMaxTime: '17:00:00',
          snapDuration: '00:15:00',
          slotDuration: '00:15:00',
          height: '100%',
          expandRows: true,
          allDaySlot: false,
          dayHeaderFormat: {
            weekday: 'short',
            day: 'numeric',
            month: 'short',
          },
          slotLabelFormat: {
            hour: 'numeric',
            minute: '2-digit',
            omitZeroMinute: false,
          },
          locale: 'da',

          buttonText: {
            today: 'I dag',
            month: 'Måned',
            week: 'Uge',
            day: 'Dag',
            list: 'Liste',
          },

          hiddenDays: [0],

          // Enable drag-and-drop editing
          editable: true,

          events: [], // Will be populated by fetchJobsAndInit

          /**
           * Event click handler - navigates to job details page.
           */
          eventClick: function (info) {
            document.location.href = '/jobliste/' + info.event.id;
          },

          /**
           * Event drop handler - updates job date/time when dragged.
           * Sends PUT request to API and reverts on failure.
           */
          eventDrop: function (info) {
            const ev = info.event;
            const payload = buildPayloadFromEvent(ev);

            fetch('/api/jobs/' + ev.id, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            })
              .then((response) => {
                if (!response.ok) throw new Error('Server returned ' + response.status);
                return response.json();
              })
              .then((updated) => {
                // Update event with fresh data from server
                const newEvent = mapJobToEvent(updated);
                ev.setProp('title', newEvent.title);
                ev.setStart(newEvent.start);
                ev.setEnd(newEvent.end);
                ev.setProp('backgroundColor', newEvent.backgroundColor);
                ev.setProp('borderColor', newEvent.borderColor);
                ev.setProp('textColor', newEvent.textColor);
                ev.setProp('classNames', newEvent.classNames);
                for (const key in newEvent.extendedProps) {
                  ev.setExtendedProp(key, newEvent.extendedProps[key]);
                }
              })
              .catch((err) => {
                console.error('Failed to update on drop:', err);
                info.revert(); // Revert the drag operation
                alert('Jobbet kunne ikke flyttes — opdateringen mislykkedes.');
              });
          },

          /**
           * Event resize handler - updates job duration when resized.
           * Calculates new work_time_minutes based on the new end time.
           */
          eventResize: function (info) {
            const ev = info.event;
            const payload = buildPayloadFromEvent(ev);

            // Calculate new duration in minutes
            if (ev.start && ev.end) {
              payload.work_time_minutes = Math.round((ev.end.getTime() - ev.start.getTime()) / 60000);
            }

            fetch('/api/jobs/' + ev.id, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            })
              .then((response) => {
                if (!response.ok) throw new Error('Server returned ' + response.status);
                return response.json();
              })
              .then((updated) => {
                // Update event with fresh data from server
                const newEvent = mapJobToEvent(updated);
                ev.setProp('title', newEvent.title);
                ev.setStart(newEvent.start);
                ev.setEnd(newEvent.end);
                ev.setProp('backgroundColor', newEvent.backgroundColor);
                ev.setProp('borderColor', newEvent.borderColor);
                ev.setProp('textColor', newEvent.textColor);
                ev.setProp('classNames', newEvent.classNames);
                for (const key in newEvent.extendedProps) {
                  ev.setExtendedProp(key, newEvent.extendedProps[key]);
                }
              })
              .catch((err) => {
                console.error('Failed to update on resize:', err);
                info.revert(); // Revert the resize operation
                alert('Kunne ikke ændre længden på jobbet — opdatering mislykkedes.');
              })
              .finally(() => {
                // Clean up any open popovers
                const inst = bootstrap.Popover.getInstance(info.el);
                if (inst) inst.dispose();
              });
          },

          /**
           * Event mount handler - sets up Bootstrap popover and context menu.
           * Called when an event element is added to the DOM.
           */
          eventDidMount: function (info) {
            // Clean up any existing popover
            const existing = bootstrap.Popover.getInstance(info.el);
            if (existing) existing.dispose();

            // Create popover with job description
            const description = info.event.extendedProps.job_description || '(Ingen beskrivelse)';
            new bootstrap.Popover(info.el, {
              title: 'Beskrivelse',
              content: description,
              trigger: 'hover',
              placement: 'left',
              container: 'body',
              html: false,
            });

            // Right-click context menu handler
            info.el.addEventListener('contextmenu', function (e) {
              e.preventDefault();
              const inst = bootstrap.Popover.getInstance(info.el);
              if (inst) inst.hide(); // Hide popover when showing context menu
              showContextMenu(e.clientX, e.clientY, info.event);
            });
          },

          /**
           * Event unmount handler - cleans up Bootstrap popover.
           * Called when an event element is removed from the DOM.
           */
          eventWillUnmount: function (info) {
            const inst = bootstrap.Popover.getInstance(info.el);
            if (inst) inst.dispose();
          },

          eventContent: function (arg) {
            // Pick a color — could also come from your event props (e.g., status color)
            const color = arg.event.backgroundColor || '#4e73df';

            return {
              html: `
        <div class="d-flex flex-column">
        <div class="d-flex align-items-center">
          <span
            class="event-dot"
            style="
              display:inline-block;
              width:10px;
              height:10px;
              border-radius:50%;
              margin-right:6px;
              flex-shrink:0;
            "
          ></span>
          <span class="event-title">${arg.event.title}</span>
        </div>
        ${
          arg.event.extendedProps.job_description && arg.event.extendedProps.work_time_minutes > 60
            ? `<span class="event-description fw-normal">${arg.event.extendedProps.job_description}</span>`
            : ''
        }

       </div>
      `,
            };
          },
        });

        // Render the calendar and load initial job data
        calendar.render();
        fetchJobsAndInit(calendar);

        // --- Global Event Handlers for Context Menu ---

        // Close menu on click outside
        document.addEventListener('click', (e) => {
          if (contextMenuEl.style.display === 'block' && !contextMenuEl.contains(e.target)) {
            hideContextMenu();
          }
        });

        // Close menu on Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') hideContextMenu();
        });

        // Close menu on scroll
        window.addEventListener('scroll', hideContextMenu, true);

        // Close menu on window resize
        window.addEventListener('resize', hideContextMenu);

        // --- Context Menu Action Handler ---
        contextMenuEl.addEventListener('click', async (e) => {
          e.stopPropagation();
          const anchor = e.target.closest('.dropdown-item');
          if (!anchor) return;

          const target = contextTargetEvent;
          hideContextMenu();
          if (!target) return;

          const action = anchor.getAttribute('data-action');

          // Open job details in current window
          if (action === 'open') {
            document.location.href = '/jobliste/' + target.id;
            return;
          }

          // Open job details in new tab
          if (action === 'openNewTab') {
            window.open('/jobliste/' + target.id, '_blank', 'noopener');
            return;
          }

          // Edit job using modal
          if (action === 'edit') {
            const ep = target.extendedProps || {};

            // Convert Date object to datetime-local input format
            const toLocalDatetimeInput = (date) => {
              if (!date) return '';
              const d = new Date(date);
              const pad = (n) => String(n).padStart(2, '0');
              return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
            };

            const jobForEdit = {
              id: target.id,
              title: ep.original_title || target.title || '',
              customer_name: ep.customer_name || '',
              customer_phone: ep.customer_phone || '',
              job_description: ep.job_description || '',
              work_time_minutes: ep.work_time_minutes ?? 0,
              price_per_minute: ep.price_per_minute ?? 0,
              date: toLocalDatetimeInput(target.start),
              status: { id: ep.status_id || 1 },
            };

            if (window.openFullEditJobModal) {
              window.openFullEditJobModal(jobForEdit);
            } else {
              alert('Edit modal er ikke tilgængelig.');
            }
            return;
          }

          // Update job status
          if (action === 'setStatus') {
            const name = anchor.getAttribute('data-status');
            const statusMap = {
              notDelivered: 1,
              delivered: 2,
              inProgress: 3,
              missingPart: 4,
              finished: 5,
              pickedUp: 6,
            };
            const newStatusId = statusMap[name];

            const ep = target.extendedProps || {};

            // Format date for API
            const toIsoLocal = (date) => {
              if (!date) return null;
              const pad = (n) => String(n).padStart(2, '0');
              const d = new Date(date);
              const yyyy = d.getFullYear();
              const MM = pad(d.getMonth() + 1);
              const dd = pad(d.getDate());
              const HH = pad(d.getHours());
              const mm = pad(d.getMinutes());
              const ss = pad(d.getSeconds());
              return `${yyyy}-${MM}-${dd}T${HH}:${mm}:${ss}`;
            };

            const payload = {
              title: ep.original_title || target.title || '',
              customer_name: ep.customer_name || '',
              customer_phone: ep.customer_phone || '',
              job_description: ep.job_description || '',
              work_time_minutes: ep.work_time_minutes ?? 0,
              price_per_minute: ep.price_per_minute ?? 0,
              date: toIsoLocal(target.start),
              status: { id: newStatusId },
            };

            try {
              const res = await fetch('/api/jobs/' + target.id, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
              });
              if (!res.ok) throw new Error('Server returned ' + res.status);
              const updated = await res.json();

              // Update event properties with new status
              const updatedStatusId = updated.status?.id ?? newStatusId;
              target.setExtendedProp('status_id', updatedStatusId);
              target.setExtendedProp('status', name);

              // Update event colors based on new status
              if (typeof statusToColors === 'function') {
                const colors = statusToColors(name);
                target.setProp('backgroundColor', colors.backgroundColor);
                target.setProp('borderColor', colors.borderColor);
                target.setProp('textColor', colors.textColor);
                target.setProp('classNames', [colors.cssClass]);
              }
            } catch (err) {
              console.error('Failed to update status:', err);
              alert('Status kunne ikke opdateres.');
            }
            return;
          }

          // Delete job
          if (action === 'delete') {
            if (!confirm('Delete this job?')) return;
            try {
              const res = await fetch('/api/jobs/' + target.id, {
                method: 'DELETE',
              });
              if (!res.ok) throw new Error('Server returned ' + res.status);
              target.remove(); // Remove event from calendar
            } catch (err) {
              console.error('Failed to delete job:', err);
              alert('Jobbet kunne ikke slettes.');
            }
          }
        });

        // Button Event Handlers

        // Refresh calendar data
        document.getElementById('refreshBtn').addEventListener('click', (e) => {
          e.preventDefault();
          fetchJobsAndInit(calendar);
        });

        window.refreshCalendarWithJob = function (createdJob) {
          calendar.addEvent(mapJobToEvent(createdJob));
        };
      });
    </script>
  </body>
</html>
